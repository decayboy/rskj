blockchain.config.name = "devnet"

peer.discovery = {

  # if peer discovery is off
  # the peer window will show
  # only what retrieved by active
  # peer [true/false]
  enabled = true

  # List of the peers to start
  # the search of the online peers
  # values: [ip:port, ip:port, ip:port ...]
  ip.list = [
    "node01.cu.az.devnet.rsklabs.io:30503",
    "node02.cu.az.devnet.rsklabs.io:30503",
    "node03.cu.az.devnet.rsklabs.io:30503",
    "node04.cu.az.devnet.rsklabs.io:30503",
    "node05.cu.az.devnet.rsklabs.io:30503",
    # "node06.cu.az.devnet.rsklabs.io:30503",
    # "node07.cu.az.devnet.rsklabs.io:30503",
    # "node08.cu.az.devnet.rsklabs.io:30503",
  ]

  # bind.ip = *

  # external IP/hostname which is reported as our host during discovery
  # if not set, the service http://checkip.amazonaws.com is used
  # the last resort is to get the peer.bind.ip address
  external.ip = node07.us-west-1.devnet.rsklabs.io
}

peer {

  # Boot node list
  active = [
    {
      ip = node01.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = 37555432ca7adcbfa5b48c7f1ad220e1e4123e80ef2e915c3677966d0af01be06d708502eef1c4124343d37f35c6b2481c4812b97371aee4d3a6b7a35849d3f4
    },
    {
      ip = node02.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = da9a6497f7d101852f2764e787bc7526dc478f878e56d3dedd1380abc820a2c316a4a06f7e61001f3d3559abfd09fbf12941be6bc5a99213ac77b93cc549abe0
    },
    {
      ip = node03.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = b89ed26abdf4204afb18a1db7130f857f1d34390d281a66408fbd47eb75a12ef76712ceed6b424feb5a43a1519bd67b353f982bb9921b9c14370a96711b2586f
    },
    {
      ip = node04.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = 7c3706853508915654db72e3ae8cb013778c0725ca31c1d7f3f398ce61dbd4284312f95032f3ce88474c331f51b12f0016b0fdeaa0e0536ecd028adbf5471d06
    },
    {
      ip = node05.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = ee99c1161eaa0be4bc039c5317b4136a1ccb41d2ef8f144e1e0f885aa36d18dad87e2164ab17557972ba4239ae1f639c0c659a995ba3d46aada3d23d96b13835
    },
    {
      ip = node06.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = baffadb9ada2f9f9d5c4ccc6a9b5e7c24d6f91d0fd5b9ef8a80d42ea89b9f5b4e0345cd9342840d2492163433390244fe25c312be3be6c9ae27308f5bc1cbdf0
    },
    {
      ip = node07.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = 63eb41b5dfcac5c2577a59122f40ae405986a3d86df6b8f44aa497eee763985214770644ffbc1eebb61695524bf6602fd21c148b55f5f948d02e9bd9d7946161
    },
    {
      ip = node08.cu.az.devnet.rsklabs.io
      port = 30503
      nodeId = adaae55b8db56a4b3f22790a84409f5d6a6863b97e7c4dad4d85bad02b1cfc24310ea9bd7dc957d95fc623442067c022b30edd4dc7035b3ac21a017af842aa0c
    },
  ]

  # list of trusted peers the incoming connections is always accepted from
  trusted = [
    # Sample entries:
    # {nodeId = "e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c"},
    # {ip = "11.22.33.44"},
    # {ip = "11.22.33.*"},
    # {
    #   nodeId = "e437a4836b77ad9d9ffe73ee782ef2614e6d8370fcf62191a6e488276e23717147073a7ce0b444d485fff5a0c34c4577251a7a990cf80d8542e21b95aa8c5e6c"
    #   ip = "11.22.33.44"
    # }
  ]

  # currently only protocol supported is RSK
  capabilities = [rsk]

  # Peer for server to listen for incoming
  # connections
  listen.port = 30503

  # connection timeout for trying to
  # connect to a peer [seconds]
  connection.timeout = 2

  # the parameter specifies how much
  # time we will wait for a message
  # to come before closing the channel
  channel.read.timeout = 30

  # Private key of the peer
  # derived nodeId = 63eb41b5dfcac5c2577a59122f40ae405986a3d86df6b8f44aa497eee763985214770644ffbc1eebb61695524bf6602fd21c148b55f5f948d02e9bd9d7946161
  # privateKey = 6044e16106d1c12465d351f1bfb521755f5a6736f7763f56495c3880054fb513
  nodeId = c26a6e1a9300d9d349dbbc6787303164be17960be689c591f9173086fe27f7d8338b073c86f55b0ab3220c91e33a58cdf649cdb7c94fe6341820394f26264d72
  privateKey = 33987643b12d4eb3b567459c74c29dbd3baceb9c1ce095edac09c9994168e539

  # Network id
  networkId = 44444444

  p2p {
    # the default version outbound connections are made with
    # inbound connections are made with the version declared by the remote peer (if supported)
    # version = 4

    # max frame size in bytes when framing is enabled
    framing.maxSize = 32768

    # forces peer to send Handshake message in format defined by EIP-8,
    # see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md
    eip8 = true
  }

  # max number of active peers our node will maintain
  # extra peers trying to connect us will be dropeed with TOO_MANY_PEERS message
  # the incoming connection from the peer matching 'peer.trusted' entry is always accepted
  maxActivePeers = 30
}

# the folder resources/genesis
# contains several versions of
# genesis configuration according
# to the network the peer will run on
genesis = rsk-dev.json

# the number of blocks should pass
# before pending transaction is removed
transaction.outdated.threshold = 10

# the number of seconds should pass
# before pending transaction is removed
# (suggested value: 10 blocks * 10 seconds by block = 100 seconds)
transaction.outdated.timeout = 100

database {
  # place to save physical storage files
  dir = db_storage

  # every time the application starts the existing database will be destroyed and all the data will be downloaded from peers again
  # having this set on true does NOT mean that the block chain will start from the last point
  # [true/false]
  reset = false
}

# this string is computed
# to be eventually the address
# that get the miner reward
coinbase.secret = monkey1

dump {
  # for testing purposes
  # all the state will be dumped
  # in JSON form to [dump.dir]
  # if [dump.full] = true
  # possible values [true/false]
  full = false
  dir = dmp

  # This defines the vmtrace dump
  # to the console and the style
  # -1 for no block trace
  # styles: [pretty/standard+] (default: standard+)
  block = -1
  style = pretty

  # clean the dump dir each start
  clean.on.restart = true
}

# structured trace
# is the trace being
# collected in the
# form of objects and
# exposed to the user
# in json or any other
# convenient form.
vm.structured {
  trace = false
  dir = vmtrace
  compressed = true
  initStorageLimit = 10000

  # enables storage disctionary db recording
  # see the org.ehereum.db.StorageDisctionary class for details
  storage.dictionary.enabled = false
}

# make changes to tracing options
# starting from certain block
# -1 don't make any tracing changes
trace.startblock = -1

# invoke vm program on
# message received,
# if the vm is not invoked
# the balance transfer
# occurs anyway  [true/false]
play.vm = true

# hello phrase will be included in
# the hello message of the peer
hello.phrase = Dev

# this property used
# mostly for a debug purpose
# so if you don't know exactly how
# to apply it leave to be [-1]
#
# ADVANCED: if we want to load a root hash
# for db not from the saved block chain (last block)
# but any manual hash this property will help.
# values [-1] - load from db
#        [hex hash 32 bytes] root hash
root.hash.start = null

# Key value data source values: [leveldb/mapdb]
keyvalue.datasource = leveldb

record.blocks=false
blockchain.only=false

# Load the blocks
# from a rlp lines
# file and not for
# the net
blocks.loader=""

# the parameter speciphy when exactly
# to switch managing storage of the
# account on autonomous db
details.inmemory.storage.limit=1

# cache for blockchain run
# the flush hapens depending
# on memory usage or blocks
# treshhold if both specipied
# memory will take precedence
cache {

  flush {

    # [0.7 = 70% memory to flush]
    memory = 0

    # [10000 flush each 10000 blocks]
    blocks = 1
  }
}

# eth sync process
sync {

  # block chain synchronization
  # can be: [true/false]
  enabled = true

  # maximum blocks hashes to ask.
  # sending GET_BLOCK_HASHES msg
  # we specify number of block we want
  # to get, recomendec value [1..1000]
  # Default: unlimited
  max.hashes.ask = 10000

  # minimal peers count
  # used in sync process
  # sync may use more peers
  # than this value
  # but always trying to get
  # at least this number from discovery
  peer.count = 10

  # whether to wait for blockchain sync to start mining and pegging.
  waitForSync = false

  # whether to do a System.exit() if something happens outside the "success flow"
  exitOnBlockConflict = true
}

# miner options
miner {
  server.enabled = false
  client.enabled = false
  minGasPrice = 0

  # these are values used by MinerServer to set the notify flag on/off
  gasUnitInDollars = 0.001
  minFeesNotifyInDollars = 30
}

simulateTxs {
  enabled = true
}

rpc {
  enabled = true
  port = 4444
  linger.time = 0

  #Number of threads accepting connections
  #acceptors.number

  #Size of the queues of requests
  #accept.queue.size

  cors = "*.rsk.co"
  modules = [
    {
      name: "eth",
      version: "1.0",
      enabled: "true",
    },
    {
      name: "net",
      version: "1.0",
      enabled: "true",
    },
    {
      name: "rpc",
      version: "1.0",
      enabled: "true",
    },
    {
      name: "web3",
      version: "1.0",
      enabled: "true",
    },
    {
      name: "evm",
      version: "1.0",
      enabled: "false",
    }
  ]
}

#federator {
#enabled = true
#bitcoinPeerAddresses = ["127.0.0.1"]
#gasPrice = 1000
#keyFile = /etc/rsk/federator.key
#}

blocks {
  enabled: false
  recorder: "blocks.txt"
}

wire {
  protocol: "rsk"
}

blockchain.newrepository = true

# solc compiler path
solc.path = /usr/bin/solc

blockchain.flush = true
blockchain.flushNumberOfBlocks = 100

# unused datasource is closed after n seconds
datasource.close = 600

# not good reputation expiration time in seconds
scoring {
  # punishment by node id
  nodes {
    # number of nodes to keep scoring
    number: 100
    # initial punishment duration (in minutes, default = 10 minutes)
    duration: 12
    # punishment duration increment (in percentage, default = 10)
    increment: 10
    # maximum punishment duration (in minutes, default = 200 minutes)
    maximum: 100
  }
  # punishment by address
  addresses {
    # initial punishment duration (in minutes, default = 10 minutes)
    duration: 12
    # punishment duration increment (in percentage, default = 10)
    increment: 10
    # maximum punishment duration (in minutes, default = 200 minutes)
    maximum: 100
  }
}


blocksforpeers = 2000

wallet {
  accounts = []
}